<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>C#实现跳一跳辅助 | 橙风沐雨&#39;s</title>
  <meta name="keywords" content=" 鼠标钩子 , 图像识别 ">
  <meta name="description" content="C#实现跳一跳辅助 | 橙风沐雨&#39;s">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="前言之前在网上找到的一个逻辑游戏NandGame 它官方介绍是这样的  The Nand Game takes you though building a working computer, starting from the most basic components. It does not require any prerequisites, in particular it does no">
<meta property="og:type" content="article">
<meta property="og:title" content="NandGame">
<meta property="og:url" content="http://example.com/2018/11/20/NandGame/index.html">
<meta property="og:site_name" content="橙风沐雨&#39;s">
<meta property="og:description" content="前言之前在网上找到的一个逻辑游戏NandGame 它官方介绍是这样的  The Nand Game takes you though building a working computer, starting from the most basic components. It does not require any prerequisites, in particular it does no">
<meta property="og:locale">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-1.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-2.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-3.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-4.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-5.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-6.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-7.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-8.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-9.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-10.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-11.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-12.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-13.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-14.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-15.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-16.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-17.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-18.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-19.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-20.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-21.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-22.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-23.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-24.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-25.png">
<meta property="og:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-26.png">
<meta property="article:published_time" content="2018-11-20T01:40:51.000Z">
<meta property="article:modified_time" content="2024-02-21T09:17:03.465Z">
<meta property="article:author" content="cfmy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/nandgame-1.png">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>cfmy</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/appendHan"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:appendHan@gmail.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(13)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="学习笔记">
            
            学习笔记
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="随笔">
            
            随笔
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="13">
<input type="hidden" id="yelog_site_word_count" value="23.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>闭包</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>观点</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>键盘驱动</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>匿名函数</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>鼠标钩子</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>图像识别</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>学习笔记</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>正则表达式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ActiveX</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Base64</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTTP协议</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Lambda</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>windows</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="All 随笔 "
           href="/2018/11/20/NandGame/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="NandGame">NandGame</span>
            <span class="post-date" title="2018-11-20 09:40:51">2018/11/20</span>
        </a>
        
        
        <a  class="All 随笔 "
           href="/2018/04/11/%E9%9A%8F%E7%AC%94-%E9%94%AE%E7%9B%98%E9%A9%B1%E5%8A%A8%E7%BA%A7%E5%88%AB%E6%A8%A1%E6%8B%9F/"
           data-tag="键盘驱动,ActiveX"
           data-author="" >
            <span class="post-title" title="随笔-键盘驱动级别模拟">随笔-键盘驱动级别模拟</span>
            <span class="post-date" title="2018-04-11 16:57:24">2018/04/11</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2018/02/26/%E6%B5%85%E8%B0%88JS%E9%97%AD%E5%8C%85/"
           data-tag="JavaScript,闭包"
           data-author="" >
            <span class="post-title" title="浅谈JS闭包">浅谈JS闭包</span>
            <span class="post-date" title="2018-02-26 10:36:24">2018/02/26</span>
        </a>
        
        
        <a  class="All 随笔 "
           href="/2018/02/23/C-%E5%AE%9E%E7%8E%B0%E8%B7%B3%E4%B8%80%E8%B7%B3%E8%BE%85%E5%8A%A9/"
           data-tag="鼠标钩子,图像识别"
           data-author="" >
            <span class="post-title" title="C#实现跳一跳辅助">C#实现跳一跳辅助</span>
            <span class="post-date" title="2018-02-23 09:29:03">2018/02/23</span>
        </a>
        
        
        <a  class="All 随笔 "
           href="/2018/01/27/%E5%85%B3%E4%BA%8E%E5%8A%AA%E5%8A%9B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="关于努力">关于努力</span>
            <span class="post-date" title="2018-01-27 19:30:33">2018/01/27</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2016/07/11/%E6%B5%85%E8%B0%88%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%8F%8ALambda/"
           data-tag="匿名函数,Lambda,学习笔记"
           data-author="" >
            <span class="post-title" title="浅谈匿名函数及Lambda">浅谈匿名函数及Lambda</span>
            <span class="post-date" title="2016-07-11 22:22:03">2016/07/11</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2016/04/24/%E6%B5%85%E8%B0%88%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="浅谈工厂模式">浅谈工厂模式</span>
            <span class="post-date" title="2016-04-24 17:58:48">2016/04/24</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2016/04/08/%E6%B5%85%E8%B0%88%E6%AD%A3%E5%88%99/"
           data-tag="正则表达式"
           data-author="" >
            <span class="post-title" title="浅谈正则">浅谈正则</span>
            <span class="post-date" title="2016-04-08 20:14:56">2016/04/08</span>
        </a>
        
        
        <a  class="All 随笔 "
           href="/2016/03/27/%E5%85%B3%E4%BA%8Ewindows%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%BA%E5%88%B6%E7%9A%84%E8%87%86%E6%83%B3/"
           data-tag="观点,windows"
           data-author="" >
            <span class="post-title" title="关于windows消息队列机制的臆想">关于windows消息队列机制的臆想</span>
            <span class="post-date" title="2016-03-27 13:15:29">2016/03/27</span>
        </a>
        
        
        <a  class="All 随笔 "
           href="/2016/03/19/Windows%E4%BF%AE%E5%A4%8D%E8%A1%A5%E4%B8%811.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows修复补丁1.2">Windows修复补丁1.2</span>
            <span class="post-date" title="2016-03-19 16:25:11">2016/03/19</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2016/03/14/%E6%B5%85%E8%B0%88Base64%E8%BD%AC%E7%A0%81/"
           data-tag="Base64"
           data-author="" >
            <span class="post-title" title="浅谈Base64转码">浅谈Base64转码</span>
            <span class="post-date" title="2016-03-14 16:40:40">2016/03/14</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2016/03/12/%E6%B5%85%E8%B0%88HTTP%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84Content-Type/"
           data-tag="HTTP协议"
           data-author="" >
            <span class="post-title" title="浅谈HTTP协议中的Content-Type">浅谈HTTP协议中的Content-Type</span>
            <span class="post-date" title="2016-03-12 21:45:54">2016/03/12</span>
        </a>
        
        
        <a  class="All 学习笔记 "
           href="/2016/02/28/Markdown%20%E8%AF%AD%E6%B3%95%E5%AE%9E%E4%BE%8B/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 语法实例">Markdown 语法实例</span>
            <span class="post-date" title="2016-02-28 16:20:05">2016/02/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-C-实现跳一跳辅助" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">C#实现跳一跳辅助</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="随笔">随笔</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">鼠标钩子</a>
            
            <a class="color5">图像识别</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-02-21 17:31:28'>2018-02-23 09:29</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:4.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-text">可行性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C"><span class="toc-text">最终效果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">图像匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%80%BB%E8%BE%91"><span class="toc-text">界面以及主逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-text">后记</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>微信跳一跳小程序原理比较简单，抛开声音要素，跳的距离与拇指按压时间成正比例，假设每次跳动距离都等于拇指按压时间*常数系数，这个游戏就变成了根据跳动距离求解按压时间，于是乎我在PC端用安卓模拟器和C#实现了一个跳一跳辅助程序</p>
</blockquote>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180223135910.bmp?imageView2/2/w/250/h/400"></p>
<ol>
<li>在模拟器确定起点和终点的位置坐标，勾股定理算出两点距离</li>
<li>一个可以实时调节大小的系数，乘以距离算出鼠标按压时间</li>
<li>根据算出的按压时间模拟鼠标按压动作</li>
</ol>
<h2 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h2><p><em>针对上述1</em>：如果想实现完全自动跳跃，肯定要用到图像匹配，从跳一跳界面来看，起点旗子的图形是固定的紫色象棋，想确定位置比较容易</p>
<p>终点的图形是新落的方块，这个方块素材目前看来官方会不断更新，如果想通过维护一个图形素材库，用来匹配终点的话非常麻烦。那么通过分解图像算出来呢？新落下的方块总是出现在界面左上或右上方，可以先取界面角落的像素点确定背景色（因为背景色会变化，需要每次起跳前确认），然后从界面左上至右下遍历像素点，比较与背景色的色差，先出现色差的区域既是新落下方块的坐标区域，这样可以吗？很难实现，首先方块颜色不是单色的，简单的根据色差判断轮廓很可能不准确，其次知道了轮廓想要确定方块顶层区域也是很有难度的</p>
<p>所以我采用半自动方式，利用人确定终点位置，人为鼠标挪到终点右键一下，记录下终点坐标，简单粗暴就是累点</p>
<p><em>针对上述2</em>：需要一个控件，每次起跳前读这里的数字</p>
<p><em>针对上述3</em>：调用win32接口，鼠标移动至界面内，鼠标左键按下，线程休眠xx毫秒，鼠标左键松开</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/QQ%E5%9B%BE%E7%89%8720180223135615.png?imageView2/1/w/650/h/500"></p>
<p><img src="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20180223141053.png?imageView2/2/w/400/h/600"></p>
<p><img src="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/20180223_143630.gif"></p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="图像匹配"><a href="#图像匹配" class="headerlink" title="图像匹配"></a>图像匹配</h2><p>这里图像匹配指的是在一个大图A中找到小图B的位置，可能是多个或一个坐标，我之前并没有处理过图像相关，所以只能在网上看人家怎么实现的，在网上找了一个比较靠谱的例子，但他只找了单个匹配结果，我改成了找多个匹配结果，具体代码如下</p>
<pre><code class="csharp">    /// &lt;summary&gt;  
    /// 判断图形里是否存在另外一个图形 所在行的索引  
    /// &lt;/summary&gt;  
    /// &lt;param name=&quot;p_Source&quot;&gt;原始图形数据&lt;/param&gt;  
    /// &lt;param name=&quot;p_Part&quot;&gt;小图形数据&lt;/param&gt;  
    /// &lt;param name=&quot;p_SourceIndex&quot;&gt;开始位置&lt;/param&gt;  
    /// &lt;param name=&quot;p_SourceWidth&quot;&gt;原始图形宽&lt;/param&gt;  
    /// &lt;param name=&quot;p_PartWidth&quot;&gt;小图宽&lt;/param&gt;  
    /// &lt;param name=&quot;p_Float&quot;&gt;溶差&lt;/param&gt;  
    /// &lt;returns&gt;所在行的索引 如果找不到返回-1&lt;/returns&gt;  
    private static int GetImageContains(byte[] p_Source, byte[] p_Part, int p_SourceIndex, int p_SourceWidth, int p_PartWidth, int p_Float)
    &#123;
        int _PartIndex = 0;
        int _SourceIndex = p_SourceIndex;
        for (int i = 0; i &lt; p_SourceWidth; i++)
        &#123;
            if (p_SourceWidth - i &lt; p_PartWidth) return -1;
            //这里放弃构造Color类，因为太耗时了，为了效率连自建color结构都不搞了，直接比较RGB三色的字节
            //Color _CurrentlyColor = Color.FromArgb(p_Source[_SourceIndex + 3], p_Source[_SourceIndex + 2], p_Source[_SourceIndex + 1], p_Source[_SourceIndex]);
            //Color _CompareColoe = Color.FromArgb(p_Part[3], p_Part[2], p_Part[1], p_Part[0]);
            _SourceIndex += 4;
    
            bool _ScanColor = ScanColor(p_Source[_SourceIndex + 2], p_Source[_SourceIndex + 1], p_Source[_SourceIndex], p_Part[2], p_Part[1], p_Part[0], p_Float);
    
            if (_ScanColor)
            &#123;
                _PartIndex += 4;
                int _SourceRVA = _SourceIndex;
                bool _Equals = true;
                for (int z = 0; z != p_PartWidth - 1; z++)
                &#123;
                    //_CurrentlyColor = Color.FromArgb(p_Source[_SourceRVA + 3], p_Source[_SourceRVA + 2], p_Source[_SourceRVA + 1], p_Source[_SourceRVA]);
                    //_CompareColoe = Color.FromArgb(p_Part[_PartIndex + 3], p_Part[_PartIndex + 2], p_Part[_PartIndex + 1], p_Part[_PartIndex]);
    
                    if (!ScanColor(p_Source[_SourceRVA + 2], p_Source[_SourceRVA + 1], p_Source[_SourceRVA], p_Part[_PartIndex + 2], p_Part[_PartIndex + 1], p_Part[_PartIndex], p_Float))
                    &#123;
                        _PartIndex = 0;
                        _Equals = false;
                        break;
                    &#125;
                    _PartIndex += 4;
                    _SourceRVA += 4;
                &#125;
                if (_Equals) return i;
            &#125;
            else
            &#123;
                _PartIndex = 0;
            &#125;
        &#125;
        return -1;
    &#125;
    
    /// &lt;summary&gt;  
    /// 检查色彩(可以根据这个更改比较方式  
    /// &lt;/summary&gt;  
    /// &lt;param name=&quot;p_CurrentlyColor&quot;&gt;当前色彩&lt;/param&gt;  
    /// &lt;param name=&quot;p_CompareColor&quot;&gt;比较色彩&lt;/param&gt;  
    /// &lt;param name=&quot;p_Float&quot;&gt;溶差&lt;/param&gt;  
    /// &lt;returns&gt;&lt;/returns&gt;  
    private static bool ScanColor(byte source_R, byte source_G, byte source_B, byte part_R, byte part_G, byte part_B, int p_Float)
    &#123;
        //int _R = p_CurrentlyColor.R;
        //int _G = p_CurrentlyColor.G;
        //int _B = p_CurrentlyColor.B;
    
        return (source_R &lt;= part_R + p_Float &amp;&amp; source_R &gt;= part_R - p_Float)
            &amp;&amp; (source_G &lt;= part_G + p_Float &amp;&amp; source_G &gt;= part_G - p_Float)
            &amp;&amp; (source_B &lt;= part_B + p_Float &amp;&amp; source_B &gt;= part_B - p_Float);
    
    &#125;
    
    /// &lt;summary&gt;  
    /// 判断图形里是否存在另外一个图形 并返回所在位置  
    /// &lt;/summary&gt;  
    /// &lt;param name=&quot;p_SourceBitmap&quot;&gt;原始图形&lt;/param&gt;  
    /// &lt;param name=&quot;p_PartBitmap&quot;&gt;小图形&lt;/param&gt;  
    /// &lt;param name=&quot;p_Float&quot;&gt;溶差&lt;/param&gt;  
    /// &lt;returns&gt;坐标&lt;/returns&gt;  
    public static List&lt;Point&gt; GetAllPoints(Bitmap p_SourceBitmap, Bitmap p_PartBitmap, int p_Float)
    &#123;
        var pointList = new List&lt;Point&gt;();
        int _SourceWidth = p_SourceBitmap.Width;
        int _SourceHeight = p_SourceBitmap.Height;
    
        int _PartWidth = p_PartBitmap.Width;
        int _PartHeight = p_PartBitmap.Height;
    
        Bitmap _SourceBitmap = new Bitmap(_SourceWidth, _SourceHeight);
        Graphics _Graphics = Graphics.FromImage(_SourceBitmap);
        _Graphics.DrawImage(p_SourceBitmap, new System.Drawing.Rectangle(0, 0, _SourceWidth, _SourceHeight));
        _Graphics.Dispose();
    
        BitmapData _SourceData = _SourceBitmap.LockBits(new System.Drawing.Rectangle(0, 0, _SourceWidth, _SourceHeight), ImageLockMode.ReadWrite, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
        byte[] _SourceByte = new byte[_SourceData.Stride * _SourceHeight];
        Marshal.Copy(_SourceData.Scan0, _SourceByte, 0, _SourceByte.Length);  //复制出p_SourceBitmap的相素信息   
        _SourceBitmap.UnlockBits(_SourceData);
    
        Bitmap _PartBitmap = new Bitmap(_PartWidth, _PartHeight);
        _Graphics = Graphics.FromImage(_PartBitmap);
        _Graphics.DrawImage(p_PartBitmap, new System.Drawing.Rectangle(0, 0, _PartWidth, _PartHeight));
        _Graphics.Dispose();
        BitmapData _PartData = _PartBitmap.LockBits(new System.Drawing.Rectangle(0, 0, _PartWidth, _PartHeight), ImageLockMode.ReadWrite, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
        byte[] _PartByte = new byte[_PartData.Stride * _PartHeight];
        Marshal.Copy(_PartData.Scan0, _PartByte, 0, _PartByte.Length);   //复制出p_PartBitmap的相素信息   
        _PartBitmap.UnlockBits(_PartData);
    
        //匹配基本思路如下
        //1. 先遍历原图Y坐标
        //2.    遍历匹配图Y坐标AS目标坐标
        //3.        找出该行完全匹配的X坐标，如果没有，原图Y+1，重复步骤1
        //          如果成功找到X，目标坐标Y+1，再次匹配，但是X值必须一致，直至目标Y最大，匹配结束
        for (int _PointY = 0; _PointY != _SourceHeight; _PointY++)
        &#123;
            if (_SourceHeight - _PointY &lt; _PartHeight) break;  //如果 剩余的高 比需要比较的高 还要小 就直接返回               
            int _PointX = -1;    //临时存放坐标 需要保证找到的是在一个X点上  
            bool _SacnOver = true;   //是否都比配的上  
            for (int z = 0; z != _PartHeight - 1; z++)       //循环目标进行比较  
            &#123;
                int _TrueX = GetImageContains(_SourceByte, _PartByte, _PointY * _SourceData.Stride, _SourceWidth, _PartWidth, p_Float);
    
                if (_TrueX == -1)   //如果没找到   
                &#123;
                    _PointX = -1;    //设置坐标为没找到  
                    _SacnOver = false;   //设置不进行返回  
                    //_SourceByte = _SourceByte.Skip(_SourceData.Stride).ToArray();
                    //_SourceHeight = _SourceHeight - 1;
                    break;
                &#125;
                else
                &#123;
                    if (z == 0) _PointX = _TrueX;
                    if (_PointX != _TrueX)   //如果找到了 也的保证坐标和上一行的坐标一样 否则也返回  
                    &#123;
                        _PointX = -1;//设置坐标为没找到  
                        _SacnOver = false;  //设置不进行返回  
                        //_SourceByte = _SourceByte.Skip(_SourceData.Stride).ToArray();
                        //_SourceHeight = _SourceHeight - 1;
                        break;
                    &#125;
                &#125;
            &#125;
            if (_SacnOver)
            &#123;
                //加入集合
                pointList.Add(new Point(_PointX, _PointY));
                //矩形涂黑
                var tmpX = _PointX + _PartWidth;
                var tmpY = _PointY + _PartHeight;
                for (int y = 0; y &lt; tmpY; y++)
                &#123;
                    for (int x = 0; x &lt; tmpX; x++)
                    &#123;
                        var index = y * _SourceData.Stride + x * 4;
                        _SourceByte[index] = 255;
                        _SourceByte[index + 1] = 255;
                        _SourceByte[index + 2] = 255;
                        _SourceByte[index + 3] = 255;
                    &#125;
                &#125;
                //重置Y坐标
                _PointY = 0;
    
                //Bitmap tmpBitmap = new Bitmap(_SourceWidth, _SourceHeight);
                //BitmapData tmBitmapData = tmpBitmap.LockBits(new System.Drawing.Rectangle(0, 0, _SourceWidth, _SourceHeight), ImageLockMode.ReadWrite, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
                //Marshal.Copy(_SourceByte, 0, tmBitmapData.Scan0, _SourceByte.Length);   //复制出p_PartBitmap的相素信息   
                ////byte[] source, int startIndex, IntPtr destination, int length
                //tmpBitmap.UnlockBits(_PartData);
    
    
                //Graphics tmpGraphics = Graphics.FromImage(tmpBitmap);
                //tmpGraphics.DrawImage(tmpBitmap, new System.Drawing.Rectangle(0, 0, _SourceWidth, _SourceHeight));
                //tmpGraphics.Dispose();
    
                //tmpBitmap.Save(&quot;test.bmp&quot;);
            &#125;
    
        &#125;
        return pointList;
    &#125;
    ```
    

我改成匹配多个结果的时候用的方法是把匹配到结果图形右下角到坐标0,0的区域涂黑，然后重新匹配，直到没有结果为止。但是这个跳一跳不用匹配多个结果，他只要这个方法确定象棋位置就可以
    
    
## 鼠标钩子

这部分其实比较简单，就是调用 user32.dll 外部方法，搞几个委托处理下回调函数，有一个需要注意点就是钩子的回调函数必须搞成静态变量，不然会被GC回收掉，导致回调报错，我自己整理的钩子类如下
    
``` csharp
    /// &lt;summary&gt;
    /// 全局钩子
    /// &lt;/summary&gt;
    public class Hook
    &#123;
        private const int WM_MOUSEMOVE = 0x200;//鼠标移动
        private const int WM_LBUTTONDOWN = 0x201;//左键按下
        private const int WM_RBUTTONDOWN = 0x204;//右键按下
        private const int WM_MBUTTONDOWN = 0x207;//滚轮按下
        private const int WM_LBUTTONUP = 0x202;//左键松开
        private const int WM_RBUTTONUP = 0x205;//右键松开
        private const int WM_MBUTTONUP = 0x208;//滚轮松开
        private const int WM_LBUTTONDBLCLK = 0x203;//左键双击
        private const int WM_RBUTTONDBLCLK = 0x206;//右键双击
        private const int WM_MBUTTONDBLCLK = 0x209;//滚轮双击
        private const int WH_KEYBOARD_LL = 13; //键盘
        private const int WH_MOUSE_LL = 14; // mouse hook constant
        private const int WM_KEYDOWN = 0x0100; //按下一个键
        private const int WM_KEYUP = 0x0101; //释放一个键
        private const int WM_CHAR = 0x0102; //按下某键，并已发出WM_KEYDOWN，WM_KEYUP消息
        private const int WM_SYSKEYDOWN = 0x0104; //当用户按住ALT键同时按下其它键时提交此消息给拥有焦点的窗口
        private const int WM_SYSKEYUP = 0x0105; //当用户释放一个键同时ALT 键还按着时提交此消息给拥有焦点的窗口
        private const int WM_SYSCHAR = 0x0106; //当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后提交此消息给拥有焦点的窗口
    
        /// &lt;summary&gt;
        /// 点
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential)]
        public class POINT
        &#123;
            public int x;
            public int y;
        &#125;
    
        /// &lt;summary&gt;
        /// 鼠标钩子结构体
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential)]
        public class MouseHookStruct
        &#123;
            public POINT pt;
            public int hWnd;
            public int wHitTestCode;
            public int dwExtraInfo;
        &#125;
        /// &lt;summary&gt;
        /// 键盘钩子结构体
        /// &lt;/summary&gt;
        [StructLayout(LayoutKind.Sequential)]
        public class KeyBoardHookStruct
        &#123;
            public int vkCode;
            public int scanCode;
            public int flags;
            public int time;
            public int dwExtraInfo;
        &#125;
    
    
        // 装置钩子的函数
        [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        public static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId);
    
        // 卸下钩子的函数
        [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        public static extern bool UnhookWindowsHookEx(int idHook);
    
        // 下一个钩挂的函数
        [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        public static extern int CallNextHookEx(int idHook, int nCode, Int32 wParam, IntPtr lParam);
    
        // 全局的鼠标事件
        public event MouseEventHandler OnMouseActivity;
    
        // 全局的键盘事件
        public event System.Windows.Forms.KeyEventHandler OnKeyBoardActivity;
    
        // 钩子回调函数
        public delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam);
    
        // 声明鼠标钩子事件类型
        //private HookProc _mouseHookProcedure;
        //private HookProc _keyBoacrdHookProcedure;
        private static int _hMouseHook = 0; // 鼠标钩子句柄 卸载钩子需要使用
        private static int _hKeyBoardHook = 0; // 键盘钩子句柄 卸载钩子需要使用
    
        /// &lt;summary&gt;
        /// 构造函数
        /// &lt;/summary&gt;
        public Hook()
        &#123;
    
        &#125;
    
        /// &lt;summary&gt;
        /// 析构函数
        /// &lt;/summary&gt;
        ~Hook()
        &#123;
            StopMouseHook();
        &#125;
        private static HookProc _mouseHookProcedure;
        /// &lt;summary&gt;
        /// 启动鼠标钩子
        /// &lt;/summary&gt;
        public void StartMouseHook()
        &#123;
            // 安装鼠标钩子
            if (_hMouseHook == 0)
            &#123;
                // 生成一个HookProc的实例.
    
                _mouseHookProcedure = MouseHookProc;
                _hMouseHook = SetWindowsHookEx(WH_MOUSE_LL, _mouseHookProcedure, IntPtr.Zero, 0);
    
                //假设装置失败停止钩子
                if (_hMouseHook == 0)
                &#123;
                    StopMouseHook();
                    throw new Exception(&quot;SetWindowsHookEx failed.&quot;);
                &#125;
            &#125;
        &#125;
    
        /// &lt;summary&gt;
        /// 停止鼠标钩子
        /// &lt;/summary&gt;
        public void StopMouseHook()
        &#123;
            bool retMouse = true;
    
            if (_hMouseHook != 0)
            &#123;
                retMouse = UnhookWindowsHookEx(_hMouseHook);
                _hMouseHook = 0;
            &#125;
    
            // 假设卸下钩子失败
            if (!(retMouse))
                throw new Exception(&quot;UnhookWindowsHookEx failed.&quot;);
        &#125;
    
        /// &lt;summary&gt;
        /// 鼠标钩子回调函数
        /// &lt;/summary&gt;
        private int MouseHookProc(int nCode, Int32 wParam, IntPtr lParam)
        &#123;
            // 假设正常执行而且用户要监听鼠标的消息
            if ((nCode &gt;= 0) &amp;&amp; (OnMouseActivity != null))
            &#123;
                MouseButtons button = MouseButtons.None;
                int clickCount = 0;
    
                switch (wParam)
                &#123;
                    case WM_LBUTTONDOWN:
                        break;
                    case WM_LBUTTONUP:
                        button = MouseButtons.Left;
                        clickCount = 1;
                        break;
                    case WM_LBUTTONDBLCLK:
                        button = MouseButtons.Left;
                        clickCount = 2;
                        break;
                    case WM_RBUTTONDOWN:
                        break;
                    case WM_RBUTTONUP:
                        button = MouseButtons.Right;
                        clickCount = 1;
                        break;
                    case WM_RBUTTONDBLCLK:
                        button = MouseButtons.Right;
                        clickCount = 2;
                        break;
                &#125;
    
                // 从回调函数中得到鼠标的信息
                MouseHookStruct myMouseHookStruct = (MouseHookStruct)Marshal.PtrToStructure(lParam, typeof(MouseHookStruct));
                MouseEventArgs e = new MouseEventArgs(button, clickCount, myMouseHookStruct.pt.x, myMouseHookStruct.pt.y, 0);
    
                // 假设想要限制鼠标在屏幕中的移动区域能够在此处设置
                // 后期须要考虑实际的x、y的容差
                //if (!Screen.PrimaryScreen.Bounds.Contains(e.X, e.Y))
                //&#123;
                //    //return 1;
                //&#125;
    
                OnMouseActivity(this, e);
            &#125;
    
            // 启动下一次钩子
            return CallNextHookEx(_hMouseHook, nCode, wParam, lParam);
        &#125;
        private static HookProc _keyBoacrdHookProcedure;
        /// &lt;summary&gt;
        /// 启动键盘钩子
        /// &lt;/summary&gt;
        public void StartKeyBoardHook()
        &#123;
            // 安装鼠标钩子
            if (_hKeyBoardHook == 0)
            &#123;
                // 生成一个HookProc的实例.
                _keyBoacrdHookProcedure = KeyBoardHookProc;
    
                _hKeyBoardHook = SetWindowsHookEx(WH_KEYBOARD_LL, _keyBoacrdHookProcedure, IntPtr.Zero, 0);
    
                //假设装置失败停止钩子
                if (_hKeyBoardHook == 0)
                &#123;
                    StopKeyBoardHook();
                    throw new Exception(&quot;SetWindowsHookEx failed.&quot;);
                &#125;
            &#125;
        &#125;
    
        /// &lt;summary&gt;
        /// 停止键盘钩子
        /// &lt;/summary&gt;
        public void StopKeyBoardHook()
        &#123;
            bool retMouse = true;
    
            if (_hKeyBoardHook != 0)
            &#123;
                retMouse = UnhookWindowsHookEx(_hKeyBoardHook);
                _hKeyBoardHook = 0;
            &#125;
    
            // 假设卸下钩子失败
            if (!(retMouse))
                throw new Exception(&quot;UnhookWindowsHookEx failed.&quot;);
        &#125;
    
        /// &lt;summary&gt;
        /// 键盘钩子回调函数
        /// &lt;/summary&gt;
        private int KeyBoardHookProc(int nCode, Int32 wParam, IntPtr lParam)
        &#123;
            // 假设正常执行而且用户要监听鼠标的消息
            if ((nCode &gt;= 0) &amp;&amp; (OnKeyBoardActivity != null))
            &#123;
                KeyBoardHookStruct kbh = (KeyBoardHookStruct)Marshal.PtrToStructure(lParam, typeof(KeyBoardHookStruct));
                var k = (Keys)Enum.Parse(typeof(Keys), kbh.vkCode.ToString());
    
                switch (k)
                &#123;
                    case Keys.F10:
                        if (wParam == WM_KEYDOWN)
                        &#123;
                            Keys keyData = (Keys)kbh.vkCode;
                            System.Windows.Forms.KeyEventArgs e = new System.Windows.Forms.KeyEventArgs(keyData);
                            OnKeyBoardActivity(this, e);
                            break;
                        &#125;
                        else
                        &#123;
                            break;
                        &#125;
                    default:
                        return -1;
                &#125;
    
            &#125;
    
            // 启动下一次钩子
            return CallNextHookEx(_hKeyBoardHook, nCode, wParam, lParam);
        &#125;
    &#125;
</code></pre>
<h2 id="界面以及主逻辑"><a href="#界面以及主逻辑" class="headerlink" title="界面以及主逻辑"></a>界面以及主逻辑</h2><p>因为每次跳动都要确定模拟器的区域，所以第一步我先获取句柄，然后根据窗体句柄获取模拟器界面边界，屏幕截图在截取出模拟器的界面，得到匹配用的原图</p>
<p>素材图片，就是旗子身体的一部分，因为根据模拟器窗体大小会变化，所以采用读取本件的方法，这意味着你要事先截取好素材图片，需要注意的是之前自己写的图片匹配方法比较死板，所以素材图片不能把背景搞进去，不然肯定匹配不出来</p>
<p>然后就是 user32一些外部方法，用来移动鼠标，模拟鼠标操作</p>
<pre><code class="csharp">    #region 跳一跳相关
    
    RECT _jumpRect = new RECT();//模拟器坐标
    string _pieceImgPath = String.Empty;//棋子图片路径
    /// &lt;summary&gt;
    /// 鼠标取句柄按钮点击
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void button3_Click_1(object sender, RoutedEventArgs e)
    &#123;
        //开启钩子监听鼠标点击事件
        hook.OnMouseActivity += Jump1HookActivity;
        hook.StartMouseHook();
    &#125;
    /// &lt;summary&gt;
    /// 鼠标钩子左键回调
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;mouseEventArgs&quot;&gt;&lt;/param&gt;
    private void Jump1HookActivity(object sender, System.Windows.Forms.MouseEventArgs mouseEventArgs)
    &#123;
        if (mouseEventArgs.Button == MouseButtons.Left &amp;&amp; mouseEventArgs.Clicks == 1)
        &#123;
            //当前鼠标坐标
            var point = new POINT();
            GetCursorPos(out point);
            //句柄
            formHandle = WindowFromPoint(point);
            //标题
            var title = new StringBuilder(256);
            GetWindowText(formHandle, title, title.Capacity);
            //类名
            var className = new StringBuilder();
            GetClassName(formHandle, className, className.Capacity);
            //Size
            _jumpRect = new RECT();
            GetWindowRect(formHandle, ref _jumpRect);
            AddLog($&quot;句柄采集成功！窗体坐标范围为 &#123;_jumpRect.Left&#125;,&#123;_jumpRect.Top&#125;-&#123;_jumpRect.Right&#125;,&#123;_jumpRect.Bottom&#125;&quot;);
            AddLog($&quot;窗体大小 Width:&#123;_jumpRect.Right - _jumpRect.Left&#125;,Height:&#123;_jumpRect.Bottom - _jumpRect.Top&#125;&quot;);
            hook.StopMouseHook();
            hook.OnMouseActivity -= Jump1HookActivity;
        &#125;
    &#125;
    
    private void AddLog(string str)
    &#123;
        if (!string.IsNullOrWhiteSpace(textBox3.Text))
        &#123;
            textBox3.Text += Environment.NewLine;
        &#125;
        textBox3.Text += $&quot;&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;：&#123;str&#125;&quot;;
        textBox3.ScrollToEnd();
    &#125;
    /// &lt;summary&gt;
    /// 取象棋图片素材
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void button4_Click(object sender, RoutedEventArgs e)
    &#123;
        //初始化一个OpenFileDialog类
        OpenFileDialog fileDialog = new OpenFileDialog();
        fileDialog.Multiselect = false;
        fileDialog.Filter = &quot;(*.bmp)|*.bmp&quot;;
    
        //判断用户是否正确的选择了文件
        if (fileDialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
        &#123;
            //获取用户选择文件的后缀名
            string extension = Path.GetExtension(fileDialog.FileName);
            //声明允许的后缀名
            string[] str = new string[] &#123; &quot;.bmp&quot;, &quot;.BMP&quot; &#125;;
            if (!((IList)str).Contains(extension))
            &#123;
                MessageBox.Show(&quot;只能处理BMP格式图片&quot;);
            &#125;
            else
            &#123;
                _pieceImgPath = fileDialog.FileName;
                AddLog($&quot;棋子素材路径读取成功 &#123;_pieceImgPath&#125;&quot;);
            &#125;
        &#125;
    &#125;
    /// &lt;summary&gt;
    /// 开始
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void button5_Click(object sender, RoutedEventArgs e)
    &#123;
        //开启钩子监听鼠标右键
        hook.OnMouseActivity += Jump2HookActivity;
        hook.StartMouseHook();
    &#125;
    /// &lt;summary&gt;
    /// 鼠标钩子右键回调
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;mouseEventArgs&quot;&gt;&lt;/param&gt;
    private void Jump2HookActivity(object sender, System.Windows.Forms.MouseEventArgs mouseEventArgs)
    &#123;
        if (mouseEventArgs.Button == MouseButtons.Right &amp;&amp; mouseEventArgs.Clicks == 1)
        &#123;
            Bitmap image1 = new Bitmap(_jumpRect.Right - _jumpRect.Left, _jumpRect.Bottom - _jumpRect.Top);//截取屏幕
            Graphics imgGraphics = Graphics.FromImage(image1);
            imgGraphics.CopyFromScreen(new System.Drawing.Point(_jumpRect.Left, _jumpRect.Top), new System.Drawing.Point(0, 0),
                new System.Drawing.Size(_jumpRect.Right - _jumpRect.Left, _jumpRect.Bottom - _jumpRect.Top));
            //image1.Save(&quot;test.bmp&quot;);
    
            Bitmap image2 = (Bitmap)System.Drawing.Image.FromFile(_pieceImgPath);
            _points = ToFindPic.GetAllPoints(image1, image2, 10);
            if (_points == null || _points.Count == 0)
            &#123;
                AddLog(&quot;没有匹配到棋子坐标&quot;);
                return;
            &#125;
    
            var pointPeople = new System.Windows.Point(_jumpRect.Left + _points[0].X, _jumpRect.Top + _points[0].Y);
            //偏移坐标
            pointPeople.X += image2.Width / 2;
            pointPeople.Y += image2.Height / 2;
    
            //SetCursorPos(Convert.ToInt32(pointPeople.X), Convert.ToInt32(pointPeople.Y));//test
    
            var pointTarget = new Point(mouseEventArgs.X, mouseEventArgs.Y);
            var distance = Math.Sqrt(Math.Pow(pointTarget.X - pointPeople.X, 2) + Math.Pow(pointTarget.Y - pointPeople.Y, 2));
            var coefficient = 3.6;
            if (pointTarget.X &lt; pointPeople.X)
            &#123;
                coefficient = Convert.ToDouble(this.textBox_jumpX.Text);//系数
            &#125;
            else
            &#123;
                coefficient = Convert.ToDouble(this.textBox_jumpY.Text);//系数
            &#125;
    
            var pressTime = new TimeSpan(0, 0, 0, 0, Convert.ToInt32(coefficient * distance));//毫秒
    
    
            var random = new Random();
            SetCursorPos(_jumpRect.Right - random.Next(150, 250), _jumpRect.Top + random.Next(150, 250));//移动鼠标位置
            mouse_event(MouseEventFlag.LeftDown, 0, 0, 0, UIntPtr.Zero);
            var now = DateTime.Now;
            Thread.Sleep(pressTime);
            var ts = DateTime.Now - now;
            AddLog($&quot;预计耗时&#123;pressTime.Milliseconds&#125;,实际耗时&#123;ts.TotalMilliseconds&#125;&quot;);
            mouse_event(MouseEventFlag.LeftUp, 0, 0, 0, UIntPtr.Zero);
        &#125;
    &#125;
    /// &lt;summary&gt;
    /// stop
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
    private void button6_Click(object sender, RoutedEventArgs e)
    &#123;
        hook.StopMouseHook();
        hook = new Hook();
    &#125;
    
    #endregion
</code></pre>
<p>user32部分</p>
<pre><code class="csharp">    #region user32
    //句柄窗体相关
    [DllImport(&quot;user32.dll&quot;)]
    public static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
    [DllImport(&quot;user32.dll&quot;)]
    public static extern int GetClassName(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
    [DllImport(&quot;user32.dll&quot;)]
    public static extern IntPtr WindowFromPoint(POINT point);
    [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto)]
    public static extern bool GetCursorPos(out POINT point);
    [DllImport(&quot;user32.dll&quot;)]
    public static extern int SetCursorPos(int x, int y);
    [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetParent&quot;, SetLastError = true)]
    public static extern IntPtr GetParent(IntPtr hWnd);
    [DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetWindowThreadProcessId&quot;)]
    public static extern uint GetWindowThreadProcessId(IntPtr hWnd, ref uint lpdwProcessId);
    //设置鼠标按键和动作
    [Flags]
    enum MouseEventFlag : uint //设置鼠标动作的键值
    &#123;
        Move = 0x0001,               //发生移动
        LeftDown = 0x0002,           //鼠标按下左键
        LeftUp = 0x0004,             //鼠标松开左键
        RightDown = 0x0008,          //鼠标按下右键
        RightUp = 0x0010,            //鼠标松开右键
        MiddleDown = 0x0020,         //鼠标按下中键
        MiddleUp = 0x0040,           //鼠标松开中键
        XDown = 0x0080,
        XUp = 0x0100,
        Wheel = 0x0800,              //鼠标轮被移动
        VirtualDesk = 0x4000,        //虚拟桌面
        Absolute = 0x8000
    &#125;
    [DllImport(&quot;user32.dll&quot;)]
    static extern void mouse_event(MouseEventFlag flags, int dx, int dy, uint data, UIntPtr extraInfo); //UIntPtr指针多句柄类型
    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    &#123;
        public int X;
        public int Y;
    
        public POINT(int x, int y)
        &#123;
            this.X = x;
            this.Y = y;
        &#125;
    
        public override string ToString()
        &#123;
            return (&quot;X:&quot; + X + &quot;, Y:&quot; + Y);
        &#125;
    &#125;
    [DllImport(&quot;user32.dll&quot;)]
    [return: MarshalAs(UnmanagedType.Bool)]
    static extern bool GetWindowRect(IntPtr hWnd, ref RECT lpRect);
    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    &#123;
        public int Left;                             //最左坐标
        public int Top;                             //最上坐标
        public int Right;                           //最右坐标
        public int Bottom;                        //最下坐标
    &#125;
    
    [DllImport(&quot;User32.dll&quot;, EntryPoint = &quot;FindWindow&quot;)]
    private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    [DllImport(&quot;User32.dll&quot;, EntryPoint = &quot;FindWindowEx&quot;)]
    private static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpClassName, string lpWindowName);
    
    //鼠标钩子相关
    [StructLayout(LayoutKind.Sequential)]
    public class MouseHookStruct
    &#123;
        public POINT pt;
        public int hwnd;
        public int wHitTestCode;
        public int dwExtraInfo;
    &#125;
    public delegate int HookProc(int nCode, IntPtr wParam, IntPtr lParam);
    //安装钩子
    [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
    public static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId);
    //卸载钩子
    [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
    public static extern bool UnhookWindowsHookEx(int idHook);
    //调用下一个钩子
    [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
    public static extern int CallNextHookEx(int idHook, int nCode, IntPtr wParam, IntPtr lParam);
    
    
    #endregion
</code></pre>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ol>
<li>效果图每次右键一次会记两次日志是因为我之前点了两次go按钮，导致每次右键回调了2次 <img src="https://cfmyhome-1256032936.cos.ap-shanghai.myqcloud.com/QQ%E5%9B%BE%E7%89%8720180223153808.gif" alt="这可真蠢"></li>
<li>跳一跳后台估计会根据连续perfect次数判断是否用作弊，如果它判断你作弊就不记录成绩了，而且我怀疑只要你超过一定分数他都直接判你作弊，然后骗一波个人照去申诉，因为作不作弊没那么容易区分</li>
<li>图像匹配和识别简单的很容易实现，但是想实现复杂一些的，比如扭曲倾斜的图片，没有研究过理论光靠直觉是想不出解决方案的，还是很有深度</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 appendHan@gmail.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 cfmy
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
